# -*- coding: utf-8 -*-
"""Defect Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-G5NPNutZ5my_zgHHTZvj_7l1MCFTJRc
"""

# Remove the pip install command as it's not needed for script execution
# !pip install together

from together import Together
import re

system_prompt = """\
**Task:** Analyze the provided image of a manufacturing pallet for defects like cracks, dents, breakage, missing parts, or wear and tear. Also add some comments regarding the defect of the pallet, it's location, etc in 2-3 lines.

**Output Requirements:**
1. Detailed reasoning and observations
2. **Final Decision:** Must be either "[DEFECT]" or "[NO DEFECT]" in bold, enclosed in square brackets

**Response Format:**
**Analysis:**

**Final Decision:** [DECISION]"""

API_KEY = "c43783c564904b7881729f0770df4c0e368f0a9923de7de5cec1879d2b938659"

client = Together(api_key=API_KEY)

import base64
import os
import requests
from typing import Union, Optional
from PIL import Image, ImageDraw, ImageFont
import matplotlib.pyplot as plt
import io
import numpy as np
import time
import re

def generate_sample_defect_analysis() -> str:
    """
    Generate a sample defect detection analysis without requiring an image.
    This function simulates the output that would be generated by analyzing a pallet image.
    
    Returns:
        A string containing the analysis results
    """
    try:
        # Create a sample analysis using the AI model with a text-only prompt
        content = [
            {
                "type": "text",
                "text": """Please provide a sample analysis of a manufacturing pallet for defect detection. 
                Consider common defects like cracks, dents, breakage, missing parts, or wear and tear.
                Provide a realistic analysis as if you were examining a pallet image."""
            }
        ]

        # Make the API request
        response = client.chat.completions.create(
            model="meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8",
            messages=[
                {
                    "role": "system",
                    "content": system_prompt
                },
                {
                    "role": "user",
                    "content": content
                }
            ]
        )

        full_analysis = response.choices[0].message.content
        decision = extract_decision(full_analysis)
        
        # Format the output
        output = f"""
=== PALLET DEFECT DETECTION ANALYSIS ===
Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}

{full_analysis}

=== ANALYSIS COMPLETE ===
Decision: {decision}
Status: {'DEFECT DETECTED' if decision == 'DEFECT' else 'NO DEFECT FOUND'}
"""
        
        return output

    except Exception as e:
        return f"""
=== PALLET DEFECT DETECTION ANALYSIS ===
Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}

Error occurred during analysis: {str(e)}

=== ANALYSIS FAILED ===
Decision: UNDETERMINED
Status: ERROR
"""

def analyze_pallet(image_path_or_url: str, display_results: bool = True) -> str:
    """
    Analyze a pallet from either a local image file or a URL and optionally display the image with defects marked.

    Args:
        image_path_or_url: Either a local file path or a URL to an image
        display_results: Whether to display the image with defects marked

    Returns:
        The decision extracted from the model's analysis
    """
    try:
        # Load the image for both analysis and display
        original_image = None

        # Determine if input is a URL or local path
        is_url = image_path_or_url.startswith(('http://', 'https://'))

        if is_url:
            # For URLs, load the image for display purposes
            if "imgur.com" in image_path_or_url and not image_path_or_url.startswith("https://i.imgur.com"):
                # Convert standard imgur URLs to direct image URLs
                image_id = image_path_or_url.split("/")[-1]
                image_url = f"https://i.imgur.com/{image_id}.jpg"
            else:
                image_url = image_path_or_url

            # Download image for display with better error handling and retries for Imgur
            original_image = load_image_from_url(image_url)

            # Enhanced prompt to get more structured defect location info
            content = [
                {
                    "type": "text",
                    "text": """Please analyze this pallet image in detail and answer these questions:
1. Are there any defects in the pallet? If yes, what types of defects?
2. For each defect, specify its exact location using descriptive terms like 'top right', 'bottom left', 'center left', etc.
3. Rate the severity of each defect on a scale of 1-5.
4. Is the pallet acceptable for use or should it be rejected due to defects?

Please structure your response clearly with sections for each defect found, including TYPE, LOCATION, and SEVERITY for each."""
                },
                {
                    "type": "image_url",
                    "image_url": {"url": image_url}
                }
            ]

        else:
            # For local files
            if not os.path.exists(image_path_or_url):
                raise FileNotFoundError(f"Local image file not found: {image_path_or_url}")

            # Load image for display with error handling
            try:
                original_image = Image.open(image_path_or_url)
                # Load the image fully to verify it's valid
                original_image.load()
            except Exception as img_error:
                print(f"Error loading local image: {img_error}")
                # Continue without image display functionality
                original_image = None

            # Read the file and encode as base64
            with open(image_path_or_url, "rb") as image_file:
                image_bytes = image_file.read()
                base64_image = base64.b64encode(image_bytes).decode('utf-8')

            # Detect file extension to determine MIME type
            file_extension = os.path.splitext(image_path_or_url)[1].lower()
            if file_extension in ['.jpg', '.jpeg']:
                mime_type = 'image/jpeg'
            elif file_extension == '.png':
                mime_type = 'image/png'
            elif file_extension in ['.gif']:
                mime_type = 'image/gif'
            elif file_extension in ['.webp']:
                mime_type = 'image/webp'
            else:
                mime_type = 'image/jpeg'  # Default to JPEG

            # Format for base64 data URI
            base64_data = f"data:{mime_type};base64,{base64_image}"

            # Enhanced prompt to get more structured defect location info
            content = [
                {
                    "type": "text",
                    "text": """Please analyze this pallet image in detail and answer these questions:
1. Are there any defects in the pallet? If yes, what types of defects?
2. For each defect, specify its exact location using descriptive terms like 'top right', 'bottom left', 'center left', etc.
3. Rate the severity of each defect on a scale of 1-5.
4. Is the pallet acceptable for use or should it be rejected due to defects?

Please structure your response clearly with sections for each defect found, including TYPE, LOCATION, and SEVERITY for each."""
                },
                {
                    "type": "image_url",
                    "image_url": {"url": base64_data}
                }
            ]

        # Make the API request
        response = client.chat.completions.create(
            model="meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8",
            messages=[
                {
                    "role": "system",
                    "content": system_prompt
                },
                {
                    "role": "user",
                    "content": content
                }
            ]
        )

        full_analysis = response.choices[0].message.content
        decision = extract_decision(full_analysis)

        # Display the image with defects marked if requested
        if display_results and original_image is not None:
            try:
                # Extract defect information with improved parser
                defects = extract_structured_defects(full_analysis, original_image.width, original_image.height)

                # Create a copy of the image for annotation
                marked_image = original_image.copy()
                draw = ImageDraw.Draw(marked_image)

                # Choose a font for annotations
                try:
                    font = ImageFont.truetype("arial.ttf", 20)
                    small_font = ImageFont.truetype("arial.ttf", 16)
                except IOError:
                    # Fallback to default font
                    font = ImageFont.load_default()
                    small_font = ImageFont.load_default()

                # Draw annotations for each defect
                for i, defect in enumerate(defects):
                    # Get coordinates
                    x, y = defect['coordinates']
                    defect_type = defect['type']
                    severity = defect.get('severity', '?')

                    # Draw circle with color based on severity
                    radius = int(min(30, marked_image.width // 15))

                    # Color coding by severity (if available)
                    if severity in [4, 5]:
                        color = 'red'
                    elif severity in [2, 3]:
                        color = 'orange'
                    else:
                        color = 'yellow'

                    # Draw numbered marker with colored circle
                    draw.ellipse(
                        [x - radius, y - radius, x + radius, y + radius],
                        outline=color,
                        width=3
                    )
                    draw.text(
                        (x - 5, y - 8),
                        str(i + 1),
                        fill=color,
                        font=small_font
                    )

                    # Draw defect type label
                    label = f"{defect_type} (Severity: {severity})"
                    bbox = draw.textbbox((0, 0), label, font=small_font)
                    text_width = bbox[2] - bbox[0]
                    text_height = bbox[3] - bbox[1]

                    # Position label to avoid going off-screen
                    label_x = max(5, min(x - text_width // 2, marked_image.width - text_width - 5))
                    label_y = y + radius + 5

                    # Draw background rectangle for label
                    draw.rectangle(
                        [label_x - 2, label_y - 2, label_x + text_width + 2, label_y + text_height + 2],
                        fill='white',
                        outline=color,
                        width=1
                    )
                    draw.text((label_x, label_y), label, fill=color, font=small_font)

                # Display the marked image
                plt.figure(figsize=(12, 8))
                plt.imshow(marked_image)
                plt.title('Pallet with Defects Marked')
                plt.axis('off')
                plt.show()

            except Exception as display_error:
                print(f"Error displaying results: {display_error}")

        return full_analysis

    except Exception as e:
        return f"Error analyzing pallet: {str(e)}"

def load_image_from_url(image_url):
    """
    Load an image from a URL with retry mechanism for rate-limited services like Imgur.

    Args:
        image_url: The URL of the image to load

    Returns:
        PIL.Image object or None if loading fails
    """
    # Specific headers for Imgur to avoid rate limiting
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Referer': 'https://imgur.com/'
    }

    max_retries = 3

    # Try different approaches depending on the image source
    if "imgur.com" in image_url:
        # For Imgur, use special headers and retry mechanism
        for attempt in range(max_retries):
            try:
                print(f"Attempt {attempt+1} to load image from Imgur...")
                response = requests.get(image_url, headers=headers, stream=True)
                response.raise_for_status()
                temp_file = io.BytesIO(response.content)
                temp_file.seek(0)
                image = Image.open(temp_file)
                image.load()  # Fully load the image to validate it
                print("Successfully loaded image from Imgur!")
                return image
            except Exception as e:
                print(f"Attempt {attempt+1} failed: {e}")
                if attempt < max_retries - 1:
                    wait_time = 2 ** attempt  # Exponential backoff: 1s, 2s, 4s
                    print(f"Waiting {wait_time} seconds before retrying...")
                    time.sleep(wait_time)

        # If all attempts fail for Imgur, try a direct approach without headers
        try:
            print("Trying direct approach without special headers...")
            response = requests.get(image_url, stream=True)
            temp_file = io.BytesIO(response.content)
            return Image.open(temp_file)
        except Exception as e:
            print(f"Direct approach failed: {e}")
            return None
    else:
        # For non-Imgur URLs, use standard approach
        try:
            response = requests.get(image_url, stream=True)
            response.raise_for_status()
            temp_file = io.BytesIO(response.content)
            return Image.open(temp_file)
        except Exception as e:
            print(f"Error loading image from URL: {e}")
            return None

def extract_structured_defects(analysis_text, image_width, image_height):
    """
    Extract structured defect information from model output with improved location mapping.

    Args:
        analysis_text: The text from the LLM analysis
        image_width: Width of the original image for coordinate mappingso
        image_height: Height of the original image for coordinate mapping

    Returns:
        List of defects with coordinates, type, and severity
    """
    defects = []

    # Look for sections that describe defects
    # Try to find patterns like "Type: Crack" or "LOCATION: top left"
    defect_sections = re.split(r'\n\s*(?=Defect|\d+\.\s+Defect|\*\*Defect)', analysis_text)

    # If we can't find clear sections, fall back to paragraph analysis
    if len(defect_sections) <= 1:
        defect_sections = re.split(r'\n\n+', analysis_text)

    for section in defect_sections:
        # Skip sections that don't describe defects
        if not re.search(r'defect|crack|break|damage|missing|broken', section.lower()):
            continue

        defect_info = {}

        # Extract defect type
        type_match = re.search(r'(?:TYPE|Type)[^\w]*(.*?)(?:\n|:|$)', section, re.IGNORECASE)
        if not type_match:
            type_match = re.search(r'(crack|break|splinter|missing board|nail|loose board|damaged|broken)',
                                  section, re.IGNORECASE)

        if type_match:
            defect_info['type'] = type_match.group(1).strip()
        else:
            defect_info['type'] = "Unknown defect"

        # Extract severity if available
        severity_match = re.search(r'(?:SEVERITY|Severity)[^\w]*(\d+)[^\d]*(?:5|\n|$)', section, re.IGNORECASE)
        if severity_match:
            try:
                defect_info['severity'] = int(severity_match.group(1))
            except ValueError:
                defect_info['severity'] = 0

        # Extract location information
        location_match = re.search(r'(?:LOCATION|Location)[^\w]*(.*?)(?:\n|:|$)', section, re.IGNORECASE)
        location_text = location_match.group(1).strip() if location_match else section

        # Map text location descriptions to coordinates
        coords = map_location_to_coordinates(location_text, image_width, image_height)
        defect_info['coordinates'] = coords

        defects.append(defect_info)

    # If we couldn't find any defects but the analysis mentions defects, add a default one
    if not defects and re.search(r'defect|damage|broken', analysis_text, re.IGNORECASE):
        defects.append({
            'type': "Detected defect",
            'coordinates': (image_width // 2, image_height // 2),
            'severity': 3  # Default medium severity
        })

    return defects

def map_location_to_coordinates(location_text, width, height):
    """
    Map textual location descriptions to x,y coordinates on the image.

    Args:
        location_text: Text describing the location
        width: Image width
        height: Image height

    Returns:
        (x, y) tuple of coordinates
    """
    # Default to center if no clear location is found
    x, y = width // 2, height // 2

    # Distance from edge for "top", "bottom", "left", "right"
    edge_margin = min(width, height) // 4

    # Horizontal position
    if re.search(r'\bleft\b', location_text, re.IGNORECASE):
        x = edge_margin
    elif re.search(r'\bright\b', location_text, re.IGNORECASE):
        x = width - edge_margin
    elif re.search(r'\bcenter\b|\bmiddle\b', location_text, re.IGNORECASE):
        x = width // 2

    # Vertical position
    if re.search(r'\btop\b|\bupper\b', location_text, re.IGNORECASE):
        y = edge_margin
    elif re.search(r'\bbottom\b|\blower\b', location_text, re.IGNORECASE):
        y = height - edge_margin
    elif re.search(r'\bcenter\b|\bmiddle\b', location_text, re.IGNORECASE):
        y = height // 2

    # Handle corner cases specifically
    if re.search(r'top left|upper left', location_text, re.IGNORECASE):
        x, y = edge_margin, edge_margin
    elif re.search(r'top right|upper right', location_text, re.IGNORECASE):
        x, y = width - edge_margin, edge_margin
    elif re.search(r'bottom left|lower left', location_text, re.IGNORECASE):
        x, y = edge_margin, height - edge_margin
    elif re.search(r'bottom right|lower right', location_text, re.IGNORECASE):
        x, y = width - edge_margin, height - edge_margin

    # Handle more specific positions
    if re.search(r'top center|upper center', location_text, re.IGNORECASE):
        x, y = width // 2, edge_margin
    elif re.search(r'bottom center|lower center', location_text, re.IGNORECASE):
        x, y = width // 2, height - edge_margin
    elif re.search(r'center left|middle left', location_text, re.IGNORECASE):
        x, y = edge_margin, height // 2
    elif re.search(r'center right|middle right', location_text, re.IGNORECASE):
        x, y = width - edge_margin, height // 2

    return (x, y)

def extract_decision(output: str) -> str:
    decision_match = re.search(r'\[([A-Z_ ]+)\]', output)
    return decision_match.group(1) if decision_match else "UNDETERMINED"

def main():
    """
    Main function that runs when the script is executed directly.
    Generates a sample defect detection analysis.
    """
    print("Starting Pallet Defect Detection Analysis...")
    print("=" * 50)
    
    try:
        # Generate sample analysis
        result = generate_sample_defect_analysis()
        print(result)
        
    except Exception as e:
        print(f"Error in main execution: {str(e)}")
        print("=" * 50)
        print("ANALYSIS FAILED")

if __name__ == "__main__":
    main()